<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta
    name="description"
    content="Author: Kien Nguyen <kiennt2609@gmail.com>
      A minimal Hugo theme with Tailwind CSS"
  />
  <title>
    
      Blog de TaylorDeDordogne
      | Convoluted boot
    
  </title>
  <meta name="author" content="map[email:taylordedordogne@gmail.com name:TaylorDeDordogne]" />
  <meta name="description" content="" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <link
    rel="icon"
    href="/favicon_io/favicon.ico"
    type="image/x-icon"
  />
  <link
    rel="icon"
    href="/favicon_io/favicon-16x16.png"
    size="16x16"
    type="image/png"
  />
  <link
    rel="icon"
    href="/favicon_io/favicon-32x32.png"
    size="32x32"
    type="image/png"
  />

  <link
    rel="preload"
    type="text/css"
    href="/css/rose-pine.min.css"
    integrity=""
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript>
    <link
      rel="stylesheet"
      type="text/css"
      href="/css/rose-pine.min.css"
      integrity=""
    />
  </noscript><link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  href="https://fonts.googleapis.com/css2?family=Overpass+Mono:wght@400;500;700&family=Overpass:wght@400;500;700&display=swap"
  rel="stylesheet"
/>
<link
    rel="preload"
    type="text/css"
    href="/css/toigian.min.ecb3fc40657feb9cc86a62c1b499c267d7038d4bc1614512e835b69d56a966be.css"
    integrity="sha256-7LP8QGV/65zIamLBtJnCZ9cDjUvBYUUS6DW2nVapZr4="
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript>
    <link
      rel="stylesheet"
      type="text/css"
      href="/css/toigian.min.ecb3fc40657feb9cc86a62c1b499c267d7038d4bc1614512e835b69d56a966be.css"
      integrity="sha256-7LP8QGV/65zIamLBtJnCZ9cDjUvBYUUS6DW2nVapZr4="
    />
  </noscript>

  
  <link
    rel="stylesheet"
    type="text/css"
    href="/css/light.min.29febe5c26ca625f7e2913e2509889a65637f415171eb003603102dea7cc42e0.css"
    integrity="sha256-Kf6+XCbKYl9+KRPiUJiJplY39BUXHrADYDEC3qfMQuA="
  />
  <link
    rel="stylesheet"
    type="text/css"
    href="/css/dark.min.47fea451289f4f246c4875ba0aa5f6376183f220c766f5e90d15d6e48cb7b937.css"
    integrity="sha256-R/6kUSifTyRsSHW6CqX2N2GD8iDHZvXpDRXW5Iy3uTc="
  />

  <script>
    
    if (
      localStorage.theme === "dark" ||
      (!("theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)
    ) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  </script>

  
  
  <script
    async
    defer
    src="/js/main.dfa968b06ebe7fb755eb156f7296445f20bd5ca0c82aa2eb755b1bfac4e2f294676471cf7670590073c364901a0dd5dc4b4c7b83f7a4a3c3b081f085c78fa1de.js"
    integrity="sha512-36losG6&#43;f7dV6xVvcpZEXyC9XKDIKqLrdVsb&#43;sTi8pRnZHHPdnBZAHPDZJAaDdXcS0x7g/eko8OwgfCFx4&#43;h3g=="
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({ startOnLoad: true, securityLevel: "loose" });
  </script>
  
  
</head>
<body><header style="--layer: 10">
  <div
    aria-hidden="true"
    class="absolute top-[-1000px] left-0 z-[calc(var(--layer)+1)] h-[calc(1000px+var(--page-top))] w-full bg-base"
  ></div>

  <div
    class="fixed top-0 left-0 z-[var(--layer)] flex h-header-height w-full items-center border-b px-page-gutter before:absolute before:inset-0 before:z-[-1] before:bg-base [@supports(backdrop-filter:blur(0))]:before:bg-base [@supports(backdrop-filter:blur(0))]:before:backdrop-blur-md"
  ><div
  class="lowercase italic mx-auto flex w-full max-w-content items-center justify-between"
>
  <nav>
    <ol class="flex text-md items-center">
      
  
    
  
    
  
  
  
  <li>
    
    
    <a href="/" class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">Blog de TaylorDeDordogne</a>
  </li>
  
    <li class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">/</li>
  

  
  
  
  <li>
    
    
    <a href="/write-ups/" class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">Write Ups</a>
  </li>
  
    <li class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">/</li>
  

  
  
  
    
  
  <li>
    
    
    <a href="/write-ups/convoluted-boot/" class="focus:underline focus:outline-none font-bold after:md:mx-2 after:mx-0.5">Convoluted boot</a>
  </li>
  

    </ol>
  </nav>
  <nav>
    <a href="https://nudistbeaaach.github.io//index.xml"
      ><svg
        width="18px"
        height="18px"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="1.5"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"
        />
      </svg>
    </a>
  </nav>
</div>


</div>
</header>
<main class="flex justify-center px-page-gutter py-page-top">
      <div class="min-h-content w-full max-w-content space-y-10 sm:space-y-20"><div
  class="lowercase italic mx-auto flex w-full max-w-content items-center justify-between"
>
  <nav>
    <ol class="flex text-md items-center">
      
  
    
  
    
  
  
  
  <li>
    
    
    <a href="/" class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">Blog de TaylorDeDordogne</a>
  </li>
  
    <li class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">/</li>
  

  
  
  
  <li>
    
    
    <a href="/write-ups/" class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">Write Ups</a>
  </li>
  
    <li class="text-muted focus:underline focus:outline-none after:md:mx-2 after:mx-0.5">/</li>
  

  
  
  
    
  
  <li>
    
    
    <a href="/write-ups/convoluted-boot/" class="focus:underline focus:outline-none font-bold after:md:mx-2 after:mx-0.5">Convoluted boot</a>
  </li>
  

    </ol>
  </nav>
  <nav>
    <a href="https://nudistbeaaach.github.io//index.xml"
      ><svg
        width="18px"
        height="18px"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="1.5"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z"
        />
      </svg>
    </a>
  </nav>
</div>


<article>
  <h1>Convoluted boot</h1>
  <time class="text-sm italic tabular-nums text-muted"
  >2023/01/10&nbsp;</time
>

  

  
    <div class="section">
      
        
        <a href="/tags/re/" id="tag">RE</a>
      
        
        <a href="/tags/hackthebox/" id="tag">HackTheBox</a>
      
    </div>
  


<div id="toc">
  
    
      <details open>
        <summary>Table of contents</summary>
        <div id="toc-list"><nav id="TableOfContents">
  <ol>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#analyse-du-code">Analyse du code</a>
      <ol>
        <li><a href="#analyse-de-la-fonction-main">Analyse de la fonction main</a></li>
        <li><a href="#analyse-du-code-injecté-sur-le-nouveau-segment">Analyse du code injecté sur le nouveau segment</a></li>
      </ol>
    </li>
    <li><a href="#syscall-hooking">Syscall hooking</a>
      <ol>
        <li><a href="#hooking-de-openat">Hooking de openat</a></li>
        <li><a href="#hooking-de-close">Hooking de close</a></li>
        <li><a href="#hooking-de-mmap2">Hooking de mmap2</a></li>
        <li><a href="#hooking-du-syscall-de-nombre-222">Hooking du syscall de nombre 222</a></li>
      </ol>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ol>
</nav></div>
      </details>
    
  
</div>
<div class="content"><h2 id="introduction">Introduction</h2>
<p>Ce challenge était un challenge de <code>Cracking</code> basé sur un bootkit disponible sur <code>HackTheBox</code>. J&rsquo;ai fait ce challenge avec l&rsquo;ami <a href="https://hexag0n.fr/tags/0poss/">0poss</a> que je remercie pour son aide!
Mais bref, commençons, l&rsquo;énoncé se présente comme ceci:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Some nodes in our data center have been producing unexpected errors and crash <span class="k">for</span> a <span class="k">while</span> now. When analyzing the systems offline, we couldn<span class="err">&#39;</span>t find anything wrong with them. After a very throurough investigation, we think we have it nailed down to the netboot server handling the distributions on the PXE network, we suspect a bootkit is involved. Can you figure out what is happening?
</span></span></code></pre></div><p>On démarre donc avec le bootloader <a href="https://fr.wikipedia.org/wiki/Preboot_Execution_Environment">PXE</a> en question nommé <code>convolutedboot.bin</code>, après avoir lancé <code>Binary Ninja</code> et rebasé le bootloader à l&rsquo;adresse physique <code>0x7c00</code> qui est l&rsquo;adresse physique où le <code>BIOS</code> va mapper le bootloader et où <code>PXE</code> va mapper les <code>boot file</code>.</p>
<p>On peut désassembler le bootloader avec le mode <code>x86_16</code>, en effet les bootloaders évoluent en <a href="https://wiki.osdev.org/Real_Mode">Real mode</a>, pour rappel ce mode d&rsquo;exécution se caractérisent par:</p>
<ul>
<li>Les adresses font 20 bits et correspodent aux adresses physiques</li>
<li>Pas de <code>Global Descriptor Table</code> donc pas de niveau de privilège au niveau du code.</li>
<li>Les registres de segments (CS,DS,ES,GS,FS,SS) ne sont donc pas des Segment selector mais bien les adresses physiques des segments en question.</li>
<li>Les registres utilisés ont une taille par défault de 16 bits.</li>
</ul>
<p>Pour finir les adresses utilisées sont donc des <code>adresses logiques</code> de la forme <code>Segment:Offset</code> et les adresses linéaires sont obtenues de cette manière:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Linear <span class="nv">Address</span> <span class="o">=</span> <span class="o">(</span>Segment * 16<span class="o">)</span> + Offset
</span></span></code></pre></div><p>Pour pouvoir débugger ce bootloader, l&rsquo;auteur du challenge est même très sympa avec nous dans le sens où il nous donne la commande <code>qemu</code> pour pouvoir débugger avec gdb:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">qemu-system-i386 -boot n -device e1000,netdev<span class="o">=</span>mynet0,mac<span class="o">=</span>52:54:00:12:34:56 -netdev user,id<span class="o">=</span>mynet0,net<span class="o">=</span>192.168.76.0/24,dhcpstart<span class="o">=</span>192.168.76.9,tftp<span class="o">=</span>./,bootfile<span class="o">=</span>convolutedboot.bin
</span></span></code></pre></div><p>En rajoutant les paramètres <code>-S -s</code>, on démarre un listener sur le port <code>1234</code> et il ne reste plus qu&rsquo;à lancer gdb et faire un:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">b*0x7c00
</span></span><span class="line"><span class="cl">target remote :1234
</span></span></code></pre></div><p>On va break au tout début de l&rsquo;exécution du bootloader, il faudra installer une extension gdb spécialisée pour le <code>Real Mode</code>, voici le <a href="https://stackoverflow.com/a/65442462/14458493">lien</a> pour l&rsquo;installer sans difficulté (Durant le déroulement du challenge il a été souvent nécessaire de debug le kernel une fois lancé et non pas le bootloader, dans ce cas il sera plus judicieux de switcher sur une extension adaptée).</p>
<p>Dès le début de l&rsquo;exécution du code, le bootloader saute à l&rsquo;adresse <code>0x7c16</code> sur une fonction que l&rsquo;on nommera <code>main</code>.</p>
<p><img src="./assets/screenshot_main_a.png" alt=""></p>
<h2 id="analyse-du-code">Analyse du code</h2>
<h3 id="analyse-de-la-fonction-main">Analyse de la fonction main</h3>
<p>Le bootloader va afficher la chaine de caractères &ldquo;Looking for PXE&hellip;\n\r&rdquo; avec une fonction que l&rsquo;on nommera <code>print_string</code> et qui se base sur les <a href="https://en.wikipedia.org/wiki/BIOS_interrupt_call">interruptions du BIOS</a> pour afficher des caractères à l&rsquo;écran. <br>
Le programme commence par effectuer une interruption <code>int 0x1a</code> en lui passant une constante: <code>0x5650</code>, cette procédure spécifique à <code>PXE</code> s&rsquo;appelle le <a href="http://www.pix.net/software/pxeboot/archive/pxespec.pdf">installation check interrupt</a> et sert, entre autre, à vérifier si une connection wifi est bien disponible. Si l&rsquo;interruption renvoie une valeur de <code>0x564e</code> c&rsquo;est que tous va bien. Dans notre cas si l&rsquo;interruption ne s&rsquo;est pas bien passée, le bootloader affiche &ldquo;Oh no&rdquo; avec la fonction print_string.</p>
<p><img src="./assets/screenshot_main_0.png" alt=""></p>
<p>Si il arrive à se connecter au wifi, le bootloader va devoir maintenant accéder aux fonctions de l&rsquo;API <code>iPXE</code>, pour ce faire le code suivant va être mis à profit:</p>
<p><img src="./assets/screenshot_get_api_a.png" alt=""></p>
<p>C&rsquo;est assez moche mais derrière tout ca, le processus est très simple.En lisant la documentation technique de PXE,on apprend que ce dernier met à disposition deux structures pour donner accès à son API:</p>
<ul>
<li><strong>PXENV+</strong></li>
<li><strong>!PXE</strong></li>
</ul>
<p>Un pointeur vers la structure <code>PXENV+</code> est retourné dans <code>BX</code> après l&rsquo;interruption dont nous avons précédemment parlé, on a juste à rajouter ces deux structures dans <code>Binary Ninja</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">PXENV_s</span> <span class="n">__packed</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Signature</span><span class="p">[</span><span class="mh">0x6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">Version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Checksum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">RMEntry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">PMOffset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">PMSelector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">StackSeg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">StackSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">BCCodeSeg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">BCCodeSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">BCDataSeg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">BCDataSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">UNDIDataSeg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">UNDIDataSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">UNDICodeSeg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">UNDICodeSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">PXEPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">PXE_s</span> <span class="n">__packed</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Signature</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Checksum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Revision</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">Reserved</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">UNDIROMID</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">BCROMID</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">RMEntry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">PMEntry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">PXENV_s</span> <span class="n">PXENV</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">PXE_s</span> <span class="n">PXE</span><span class="p">;</span>
</span></span></code></pre></div><p>L&rsquo;attribut <code>__packed</code> est ici pour dire au compilateur de ne pas rajouter de padding pour faire l&rsquo;alignement entre les attributs de la structure. <br>
Et après avoir renommé et changé les types des variables on obtient un résultat un peu plus compréhensible mais toujours très loin d&rsquo;être parfait à cause du fait que le code change explicitement de segment ce qui est assez laid à décompiler:</p>
<p><img src="./assets/screenshot_get_api_0.png" alt=""></p>
<p>Comme expliqué <a href="https://wiki.osdev.org/PXE">ici</a>, à partir de la version <code>2.1</code> de PXE, la structure <code>PXENV+</code> est considérée comme obsolète et le bootloader devrait utiliser <code>!PXE</code> à la place. C&rsquo;est pourquoi le code vérifie si l&rsquo;attribut <code>Version</code> de la structure <code>PXENV+</code> est supériure à <code>0x201</code> et si c&rsquo;est le cas il récupère un <code>Far Pointer</code> de la structure !PXE.</p>
<p><em>Rappel:</em>
Un <code>Far Pointer</code> est une adresse constituée de l&rsquo;association du segment <code>CS</code> et du registre <code>IP</code>. Cela permet de sauter ou d&rsquo;appeller dans un segment de code complètement différent.</p>
<p>On peut voir que Binary Ninja sépare le Far Pointer vers la structure !PXE en deux variables différentes, ce qui explique un code aussi alambiqué pour une opération si simple.
Le code accède ensuite à l&rsquo;attribut <code>RMEntry</code> de la structure !PXE, un autre Far Pointer vers l&rsquo;entry point de l&rsquo;API PXE. Il met ensuite ce Far Pointer dans la variable à <code>0x7f63</code> que l&rsquo;on nommera <code>API_buffer</code>.</p>
<p>Mais si la version de PXE est inférieure à <code>2.1</code>, le bootloader va récupérer le pointeur vers l&rsquo;entry point de l&rsquo;API directement dans la structure PXENV+.</p>
<p>Au final cet API servira au bootloader pour exécuter des commandes propres à iPXE:</p>
<ul>
<li>
<p>La commande <code>kernel</code> qui télécharge le binaire <code>vmlinuz</code> correspondant au kernel compressé.</p>
</li>
<li>
<p><code>initrd</code> pour télécharger le <a href="https://fr.wikipedia.org/wiki/Cpio">cpio</a> compressé <code>core.gz</code> de <code>TinyCore</code>.</p>
</li>
<li>
<p><code>imgfree</code> pour libérer l&rsquo;espace pris par son image.</p>
</li>
</ul>
<p>Et c&rsquo;est à cause de cette dernière commande que le bootloader va se remapper sur un autre segment. Le code suivant va recopier le code du bootloader à partir de l&rsquo;adresse <code>0x7f81</code> au début du segent <code>ES</code> à <code>0x9ac00</code>.</p>
<p><img src="./assets/screenshot_main_1.png" alt=""></p>
<p>Après avoir exécuté les commandes le bootloader push le contexte <code>CS:IP</code> correspondant à une fonction que l&rsquo;on nommera <code>boot</code>, chargée de lancer la procédure de boot du kernel. Mais il va ensuite push le nouveau contexte <code>ES:0x0</code> correspondant au code qu&rsquo;il vient de copier. <br>
Le programme va donc sauter sur le code présent à l&rsquo;adresse <code>0x9ac00</code> avant de retourner sur le code à <code>0x7d2d</code>.</p>
<p><img src="./assets/screenshot_main_2.png" alt=""></p>
<p>La suite du code du bootloader s&rsquo;exécutera donc à partir de l&rsquo;adresse <code>0x9ac00</code>.</p>
<h3 id="analyse-du-code-injecté-sur-le-nouveau-segment">Analyse du code injecté sur le nouveau segment</h3>
<p>Après avoir jeté un coup d&rsquo;oeil sur le graphe de la fonction dans <code>Binary Ninja</code>, on remarque que le code s&rsquo;apparente fortement à un <code>egg hunter</code>, le code utilise le registre <code>EDX</code> pour itérer sur toute la mémoire physique jusqu&rsquo;à y trouver une séquence d&rsquo;octets précis:</p>
<p><img src="./assets/screenshot_h0_a.png" alt=""></p>
<p>Mais avant cela, le premier <code>basic block</code> va patcher différentes zone du code du bootloader remappé en y additionnant la <code>base address 0x9ac00</code>. De cette manière les prochaines fonctions pourront fonctionner correctement. Ce système de <code>relocation</code> peut être reproduit dans <code>Binary Ninja</code> de cette manière:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Pour tous les snippets Binary Ninja qui suivront, la base adresse du bootloader sera mise à 0x7c00</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">reloc</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">reloc_address</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">reloc</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">bv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">reloc_address</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">base</span>
</span></span><span class="line"><span class="cl">    <span class="n">bv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">reloc_address</span><span class="p">,</span> <span class="n">reloc</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;little&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">base</span> <span class="o">=</span> <span class="mh">0x9ac00</span>
</span></span><span class="line"><span class="cl"><span class="n">reloc_0_address</span> <span class="o">=</span> <span class="mh">0x7f81</span> <span class="o">+</span> <span class="mh">0x12c</span>
</span></span><span class="line"><span class="cl"><span class="n">reloc_1_address</span> <span class="o">=</span> <span class="mh">0x7f81</span> <span class="o">+</span> <span class="mh">0x13b</span>
</span></span><span class="line"><span class="cl"><span class="n">patch_address</span> <span class="o">=</span> <span class="mh">0x7f81</span> <span class="o">+</span> <span class="mh">0x12b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">reloc</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">reloc_0_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [...]</span>
</span></span></code></pre></div><p>Dans la suite du <code>egg hunter</code> le programme va comparer chaque suite de 4 octets dans la mémoire jusqu&rsquo;à obtenir la bonne valeur. Pour trouver cette addresse il suffit de poser un <code>breakpoint</code> à la fin de l&rsquo;<code>egg hunter</code> pour trouver l&rsquo;adresse qui contient cette séquence d&rsquo;octets:</p>
<p><img src="./assets/screenshot_h0_0.png" alt=""></p>
<p>Et c&rsquo;est là que ca devient intéressant! L&rsquo;adresse <code>0x7ec3de8</code> appartient au kernel compressé <code>vmlinuz</code> récemment mappé cette séquence d&rsquo;opcodes se trouve à la fin de la fonction <code>extract_kernel</code> qui vient d&rsquo;extraire le kernel et de le charger à l&rsquo;adresse physique <code>0x100000</code>. <br>
La dernière étape de cette fonction est de patcher l&rsquo;adresse trouvée par le <code>egg hunter</code> avec les 20 octets situés à <code>es:0x12b</code>:</p>
<p><img src="./assets/screenshot_h0_1.png" alt=""></p>
<p>On applique le patch à la fonction <code>extract_kernel</code> dans <code>Binary Ninja</code> de cette manière:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Il faudra identifier la fonction extract_kernel dans Binary Ninja (en s&#39;appuyant sur les chaines de caractères utilisées), puis la renommer</span>
</span></span><span class="line"><span class="cl"><span class="n">bootloader</span> <span class="o">=</span> <span class="n">open_view</span><span class="p">(</span><span class="s2">&#34;/home/mitenka/Bureau/Reverse/rev_convolutedboot/convolutedboot.bndb&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">patch_address</span> <span class="o">=</span> <span class="mh">0x7f81</span> <span class="o">+</span> <span class="mh">0x12b</span>
</span></span><span class="line"><span class="cl"><span class="n">patch</span> <span class="o">=</span> <span class="n">bootloader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">patch_address</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">extract_kernel_address</span> <span class="o">=</span> <span class="n">bv</span><span class="o">.</span><span class="n">get_symbols_by_name</span><span class="p">(</span><span class="s2">&#34;extract_kernel&#34;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">address</span>
</span></span><span class="line"><span class="cl"><span class="n">bv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">extract_kernel_address</span><span class="p">,</span> <span class="n">patch</span><span class="p">)</span>
</span></span></code></pre></div><p>Une fois patchée, la fin de la fonction <code>extract_kernel</code> va passer de cette forme:</p>
<p><img src="./assets/screenshot_vmlinuz_0.png" alt=""></p>
<p>à cette forme:</p>
<p><img src="./assets/screenshot_vmlinuz_1.png" alt=""></p>
<p>Sachant que l&rsquo;adrese <code>0x9ad34</code> est l&rsquo;adresse d&rsquo;un bout de code du bootloader, l&rsquo;objectif de la fonction <code>egg hunter</code> devient maintenant plus clair! <br>
Une fois cette fonction terminée, le bootloader va sauter dans la fonction <code>boot</code> qui lancera la procédure de boot et par extension l&rsquo;exécution de la fonction <code>extract_kernel</code>, et re-sauter dans le bootloader mais cette fois avec le kernel chargé en mémoire! <br>
De grosses manigances s&rsquo;annoncent&hellip;</p>
<h2 id="syscall-hooking">Syscall hooking</h2>
<p>A ce stade là le processeur est passé en mode protected, même si du code s&rsquo;exécute dans la zone mémoire réservée par le bootloader.
La fonction du bootloader présente à l&rsquo;adresse <code>0x9ad34</code>, est très courte et assez explicite:</p>
<p><img src="./assets/screenshot_hooking_0.png" alt=""></p>
<p>Le programme déréférence 4 valeurs dans le kernel, les stocke dans un tableau de pointeurs à l&rsquo;adresse <code>0x9ad9e</code>. Et il remplace ces valeurs par des adresses appartenant à l&rsquo;image du bootloader.</p>
<p><em>Rermarque:</em>
Ces adresse en question ont une forme telle que <code>0xc00XXXXX</code> on peut en déduire que ce sont des adresses virtuelles, en effet l&rsquo;adresse physique <code>0x0</code> va être mappé à l&rsquo;adresse virtuelle <code>0xc0000000</code>. Ces pointeurs seront surement utilisés depuis le kernel une fois lancé.</p>
<p>On devine vite que l&rsquo;objectif de cette fonction est de remplacer 4 syscalls dans la <code>syscall_table</code> par des fonctions du bootloader. <br>
Il va maintenant s&rsquo;agir d&rsquo;identifier quels sont les syscalls qui sont touchés par ce hijacking, si on ne veut pas avoir à se taper le code du kernel <code>TinyCore</code> pour chaqun des 4 syscalls il va nous falloir être méthodique. Examinons de plus près la fonction qui remplace le syscall présent à <code>0x70a67c</code>:</p>
<p><img src="./assets/screenshot_openat_hook_0.png" alt=""></p>
<p>Sachant que le kernel passe les arguemnts passés dans un syscall sous forme d&rsquo;un buffer dont l&rsquo;adresse est contenue dans le registre <code>EAX</code> on peut en déduire que le second paramètre passé à ce syscall doit être un nom de fichier, en l&rsquo;occurence le nom de fichier serait comparé à &ldquo;/lib/libc.so.6&rdquo;. On peut réduire la liste des syscalls possibles à <code>openat</code>, <code>mkdonat</code>, <code>fstatat64</code> et autres possibilités exotiques.</p>
<p>Il est possible de déterminer lequel exactement car on dipsose de l&rsquo;offset dans la <code>syscall_table</code> (le syscall number) de chaque syscall. <br>
On a cette relation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">syscall_address</span> <span class="o">=</span> syscall_table + <span class="o">(</span>syscall_numer<span class="o">)</span> * <span class="m">4</span>
</span></span></code></pre></div><p>Donc pour chaque syscall potentiel on peut en déduire une adresse potentielle de la <code>syscall_table</code>, et choisir la plus cohérente, si les 4 octets avant l&rsquo;adresse potentielle sont nuls cela veut dire qu&rsquo;on a trouvé l&rsquo;adresse correcte du début de la <code>syscall_table</code>.</p>
<p><img src="./assets/screenshot_syscall_table_0.png" alt=""></p>
<p>On déduit de ce raisonnmenet que le syscall présent à <code>0x70a67c</code> est <code>openat</code> de <code>syscall number</code> <code>295</code> et que l&rsquo;adresse de la <code>syscall_table</code> est <code>0x70a1e0</code>. Il est maintenant trivial d&rsquo;identifier les autres syscalls hijackés.</p>
<p><img src="./assets/screenshot_hooking_1.png" alt=""></p>
<p>Et on remarque finalement que dans chacune des fonctions qui remplacent les syscalls, un appel au syscall originel est fait on est donc bien sur une technique de <code>syscall hooking</code>:</p>
<p><img src="./assets/screenshot_hooking_2.png" alt=""></p>
<p>Le programme remet le contexte mis en place par l&rsquo;appel au syscall et appelle la sauvegarde correspondante dans le tableau de pointeur à <code>0x9ad9e</code>.</p>
<p>La décompilation de <code>Binary Ninja</code> est trompeuse pour cette fonction, si vous vous souvenez bien l&rsquo;appel au code mettant en place les hooks était suivi d&rsquo;une boucle infinie et c&rsquo;est pour ca que le code <code>return</code> directement dans la fonction appellante de <code>extract_kernel</code> avant de jump à <code>0x100000</code>, au début du code du kernel. Ci-dessous on peut voir que le code de <code>vmlinuz</code> sauter sur l&rsquo;adresse du nouveau kernel dans le registre <code>EAX</code>, récemment extrait.</p>
<p><img src="./assets/extract_kernel_call.PNG" alt=""></p>
<p>Ce bout de code correspond à ce code source ci-dessous, présent dans le code que l&rsquo;on peut trouver <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S#L578">ici</a>, sur le repo officiel de Linux, dans le dossier dédié au kernel compressé.</p>
<p><img src="./assets/screenshot_extract_kernel_source.png" alt=""></p>
<h3 id="hooking-de-openat">Hooking de openat</h3>
<p>Comme expliqué précédemment ce hook va vérifier si le fichier à ouvrir est &ldquo;/lib/libc.so.6&rdquo; et si c&rsquo;est le cas conserver la valeur du <code>file descriptor</code> retourné au vrai syscall <code>openat</code> dans une variable globale à l&rsquo;adresse virtuelle <code>0xc009adae</code>.</p>
<p><img src="./assets/screenshot_openat_hook_1.png" alt=""></p>
<h3 id="hooking-de-close">Hooking de close</h3>
<p>Cette fonction garde le même principe que le hook de <code>openat</code>, le programme vérifie si le <code>file descriptor</code> à fermer correspond à celui de &ldquo;/lib/libc.so.6&rdquo;:</p>
<p><img src="./assets/screenshot_close_hook_0.png" alt=""></p>
<p>Puis il ferme le <code>file descriptor</code> et si il s&rsquo;agissait bien de celui associé à la libc, il clear la variable globale:</p>
<p><img src="./assets/screenshot_hook_close_1.png" alt=""></p>
<h3 id="hooking-de-mmap2">Hooking de mmap2</h3>
<p>Ce hook de <code>mmap2</code> commence par vérifier qu&rsquo;un <code>file descriptor</code> associé à la libc est bien disponible dans la variable globale, que c&rsquo;est bien ce fichier que le <code>mmap2</code> vise à mapper, et pour finir que la protection soit <code>PROT_READ</code>. Et si c&rsquo;est le cas il rajoute la protection <code>PROT_WRITE</code> est rajoutée et récupère l&rsquo;adreses où le <code>mmap2</code> doit se faire dans une variable que l&rsquo;on nommera <code>addr</code>.</p>
<p><img src="./assets/screenshot_hook_mmap2_0.png" alt=""></p>
<p>Après cela, le hook transfère les arguments au <code>mmap2</code> légitime. En résumé le hooking va faire en sorte que quand le <code>loader dynamique</code> mappe en mémoire les sections de la libc, ces dernières aient toujours la protection <code>Writable</code> en plus de <code>Readable</code>. <br>
Le code restant est très intéressant et se présente comme ceci:</p>
<p><img src="./assets/screenshot_hook_mmap2_1.png" alt=""></p>
<p>Le programme vérifie alors deux choses:</p>
<ol>
<li>
<p>Que l&rsquo;adresse de mapping retournée n&rsquo;est pas négative, c&rsquo;est à dire si l&rsquo;appel à <code>mmap2</code> s&rsquo;est bien déroulé.</p>
</li>
<li>
<p>Plus énigmatique, que la valeur sur 4 octets pointée l&rsquo;adresse où vient de se faire le mapping vaut <code>0x4b3ff</code>.
Le sens derrière cela est de vérifier si la suite d&rsquo;opcodes b&quot;\xff\xb3\x04&quot; est présente à cette adresse. <code>Binary Ninja</code> trouve 3 fois cette séquence dans la libc:</p>
</li>
</ol>
<p><img src="./assets/screenshot_hook_mmap2_2.png" alt=""></p>
<p>Une seule de ces trois adresse est alignée et correspond à un début de section (la <code>.plt</code>) que le <code>loader dynamique</code> aurait pu choisir: <code>0x19000</code>.</p>
<p>Le programme va calculer une autre adresse à partir de cette dernière avec un offset de <code>0xc6952</code> et qui correspond à l&rsquo;entry point de la fonction <code>key_decryptsession</code>. Le bootloader va ensuite copier une partie de son code (situé à l&rsquo;adresse virtuelle <code>0xc009b01b</code>) de taille <code>0x57</code> octets à la place de la fonction <code>key_decryptsession</code>.</p>
<p>Après cela le programme va de nouveau patcher la libc en ajoutant la séquence b&quot;\xe8\x47\x5f\x0c\x00&quot; à une adresse telle que: <code>.plt + 0xa06</code> et qui fait partie de la fonction <code>__libc_start_main</code> et cette séquence d&rsquo;octets correspond à un appel à la fonction <code>key_decryptsession</code>:</p>
<p>Le bootloader va donc patcher la fonction de la libc <code>key_decryptsession</code> et rajouter un call vers cette dernière dans la fonction <code>__libc_start_main</code>, chaque programme utilisant la libc exécutera un code injecté par le bootloader!</p>
<p>Il est possible de représenter cela dans <code>Binary Ninja</code> de cette manière:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bootloader</span> <span class="o">=</span> <span class="n">open_view</span><span class="p">(</span><span class="s2">&#34;/home/mitenka/Bureau/Reverse/rev_convolutedboot/convolutedboot.bndb&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Overwriting de la fonction key_decryptsession</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">source</span> <span class="o">=</span> <span class="mh">0x839c</span>
</span></span><span class="line"><span class="cl"><span class="n">func_size</span> <span class="o">=</span> <span class="mh">0x57</span>
</span></span><span class="line"><span class="cl"><span class="n">func</span> <span class="o">=</span> <span class="n">bootloader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">func_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">dest</span> <span class="o">=</span> <span class="n">bv</span><span class="o">.</span><span class="n">get_symbols_by_name</span><span class="p">(</span><span class="s2">&#34;key_decryptsession&#34;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">address</span>
</span></span><span class="line"><span class="cl"><span class="n">bv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Ajout d&#39;un appel à key_decryptsession dans __libc_start_main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">call</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\xe8\x47\x5f\x0c\x00</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span> <span class="o">=</span> <span class="mh">0x19a06</span>
</span></span><span class="line"><span class="cl"><span class="n">bv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">main</span><span class="p">,</span> <span class="n">call</span><span class="p">)</span>
</span></span></code></pre></div><p>Et voilà le résultat du patching de la libc!</p>
<p><img src="./assets/screenshot_libc_patching_0.png" alt=""></p>
<p><img src="./assets/screenshot_libc_patching_1.png" alt=""></p>
<p><em>Remarque:</em>
Pour obtenir le fichier de la libc depuis le fichier <code>core.gz</code> utilisé lors du challenge il faut tout d&rsquo;abord extraire le fichier <a href="https://fr.wikipedia.org/wiki/Cpio">cpio</a> <code>core</code> de l&rsquo;archive <code>core.gz</code> puis d&rsquo;extraire les fichiers avec la commande:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkdir fs <span class="o">&amp;&amp;</span> <span class="nb">cd</span> fs <span class="o">&amp;&amp;</span> cpio -i &lt; ../core
</span></span></code></pre></div><p>Il est maintenant possible d&rsquo;accéder au fichier <code>libc.so.6</code> ainsi qu&rsquo;au binaire <code>busybox</code>, encore merci à <code>0poss</code> pour ses gentoo skils ;) ! Il est aussi bon de remarquer que l&rsquo;OS utilisé est <code>TinyCore</code> utilisant notamment <a href="https://fr.wikipedia.org/wiki/BusyBox">Busybox</a> et que par conséquent un grand nombre des commandes de base (<code>ls</code>, <code>cat</code>, <code>cd</code>&hellip;) seront gérés par un seul exécutable <code>/bin/busybox</code>.</p>
<p>### Analyse de la libc modifiée</p>
<p>Grâce au fait que <code>Binary Ninja</code> ait en stock la signature de plusieurs fonctions de la libc, il est beaucoup plus simple d&rsquo;identifier et de comprendre le fonctionnement de la version patchée de <code>key_decryptsession</code>, voyez plutôt:</p>
<p><img src="./assets/screenshot_libc_0.png" alt=""></p>
<p>le programme va déréférencer la valeur pointée par <code>__progname</code> qui renvoie à un pointeur vers le buffer contenant le nom de base du binaire exécuté et faisant appel à la libc. La fonction compare si le binaire lancé est <code>cat</code> et si c&rsquo;est le cas il fait un appel à <code>mprotect</code> pour éditer les protections mémoire à partir de l&rsquo;adresse du binaire <code>0x804c000</code> et sur <code>0x638e0</code> octets et y mettre les protections <code>PROT_READ | PROT_WRITE | PROT_EXEC</code>. L&rsquo;adresse <code>0x804c000</code> correspond au début du segment exécutable dans le binaire <code>busybox</code>.</p>
<p>En d&rsquo;autres termes si la commande exécutée via <code>busybox</code> est &ldquo;cat&rdquo;, la libc va mettre tous le segment exécutable de ce dernier en tant que <code>Readable</code>, <code>Writable</code> et <code>Executable</code>.</p>
<p>Après cela le programme va faire un appel au syscall de nombre <code>222</code> (<code>0xde</code>), en lui passant une constante de valeur <code>0xdadb7ad</code>.</p>
<h3 id="hooking-du-syscall-de-nombre-222">Hooking du syscall de nombre 222</h3>
<p>Pour comprendre en quoi consiste cette fonction, nous allons tout d&rsquo;abord nous intéresser aux opérations faites sur le premier paramètre passé en argument au syscall:</p>
<p><img src="./assets/screenshot_hook_222_0.png" alt=""></p>
<p>On remarque une suite de multiplication et d&rsquo;addition que va subir l&rsquo;input, cela est équivalent à l&rsquo;évaluation par ce polynôme:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">P<span class="o">(</span>X<span class="o">)</span> <span class="o">=</span> 0x45f90000 * X^2 + 0xfd20dcb3 * X + 0xa0f27f57
</span></span></code></pre></div><p>Le résultat est mis dans une variable que l&rsquo;on appellera <code>var_ret</code> et qui sera retournée par le hook peu importe la vraie valeur de retour du syscall légitime. <br>
Ensuite le hook va tester si les opcodes à l&rsquo;adresse <code>0x80a4479</code> sont b&quot;\x55\x57\x56\x53&quot;, et en effet dans le binaire <code>busybox</code>, la fonction à cette adresse présente ces opcodes dans son prologue:</p>
<p><img src="./assets/screenshot_arp_main_0.png" alt=""></p>
<p>En se basant sur les chaines de caractères utilisées dans cette fontion et sur le <a href="https://github.com/mirror/busybox/blob/24198f652f10dca5603df7c704263358ca21f5ce/networking/arp.c#L487">code source</a> de <code>Busybox</code>, on identifie cette fonction en tant que <code>arp_main</code>. Donc si le prologue est toujours présent dans la fonction, ce code est exécuté:</p>
<p><img src="./assets/screenshot_hook_222_1.png" alt=""></p>
<p>Les <code>0x104</code> octets présents à dans le binaire <code>busybox</code> à l&rsquo;adresse <code>0x80a4479</code> (l&rsquo;entry point de la fonction <code>arp_main</code>) vont être <code>XOR</code>és avec ceux à l&rsquo;adresse <code>0xc009b073</code> dans le bootloader. Une fois cela fait, le bootloader va éditer les octets présents à l&rsquo;adresse <code>0x80ae28f</code> pour y rajouter un appel à la fonction <code>arp_main</code> récemment modifiée. En utilisant encore une fois le code source de <code>Busybox</code> cette fonction a pu être simplement identifiée comme <code>on open3_or_warn</code>.</p>
<p>Dans <code>Binary Ninja</code> cela peut être fait simplement comme cela:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># XORage de la fonction arp_main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bootloader</span> <span class="o">=</span> <span class="n">open_view</span><span class="p">(</span><span class="s2">&#34;/home/mitenka/Bureau/Reverse/rev_convolutedboot/convolutedboot.bndb&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">source</span> <span class="o">=</span> <span class="mh">0x7f81</span> <span class="o">+</span> <span class="mh">0x473</span>
</span></span><span class="line"><span class="cl"><span class="n">dest</span> <span class="o">=</span> <span class="n">bv</span><span class="o">.</span><span class="n">get_symbols_by_name</span><span class="p">(</span><span class="s2">&#34;arp_main&#34;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">address</span>
</span></span><span class="line"><span class="cl"><span class="n">size</span> <span class="o">=</span> <span class="mh">0x104</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">source_stub</span> <span class="o">=</span> <span class="n">bootloader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">dest_stub</span> <span class="o">=</span> <span class="n">bv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">xored</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">[</span><span class="s2">&#34;XOR&#34;</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">source_stub</span><span class="p">,</span> <span class="p">{</span><span class="s2">&#34;key&#34;</span><span class="p">:</span> <span class="n">dest_stub</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="n">bv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">xored</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Ajout d&#39;un call à la fonction arp_main dans la fonction open3_or_warn</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">open3_address</span> <span class="o">=</span> <span class="mh">0x80ae28f</span>
</span></span><span class="line"><span class="cl"><span class="n">arp_call</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\xe8\xe5\x61\xff\xff</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">bv</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">open3_address</span><span class="p">,</span> <span class="n">arp_call</span><span class="p">)</span>
</span></span></code></pre></div><p>Ce code va donc être exécuté si le syscall est appellé pour la première fois lors de l&rsquo;appel à <code>key_decryptsession</code>. <br>
Et le résulat est très intéressant! Car lorsque <code>busybox</code> va utiliser la fonction <code>open3_or_warn</code> pour accéder au contenu du fichier choisi, le nom du fichier va être passé dans la fonction nouvelle fonction <code>arp_main</code>. Et voici à quoi le début ressemble:</p>
<p><img src="./assets/screenshot_arp_main_1.png" alt=""></p>
<p>Sachant que comme expliqué précédemment le pointeur vers le nom du fichier que <code>cat</code> doit afficher se trouve dans le registre <code>EAX</code>, la fonction patchée va comparer si ce le fichier à afficher s&rsquo;appelle &ldquo;secret&rdquo;.</p>
<p>L&rsquo;appel à <code>arp_main</code> remplace un appel à la fonction <code>open64</code> chargée d&rsquo;ouvrir un fichier c&rsquo;est donc en toute logique que si le fichier affiché ne s&rsquo;appelle pas &ldquo;secret&rdquo;, la fonction <code>arp_main</code> va tout simplement renvoyer un appel à la fonction <code>open64</code> pour ne pas compromettre l&rsquo;exécution du programme <code>cat</code> comme nous pouvons le voir ci-desous:</p>
<p><img src="./assets/screenshot_arp_main_2.png" alt=""></p>
<p>Mais si le programme s&rsquo;appelle bien &ldquo;secret&rdquo;, le programme entre dans une boucle de cette forme:</p>
<ol>
<li>4 octets sont lus dans le fichier &ldquo;secret&rdquo; en question.</li>
<li>Ils sont passés sous la forme d&rsquo;un <code>int</code> dans une fonction telle que:
<code>y = x * 0xe296df0b + 0x14800841</code></li>
<li>Le résultat <code>y</code> est passé en paramètre au syscall de nombre <code>222</code>.</li>
<li>Le résultat est comparé à <code>0x544aa692</code></li>
<li>Si c&rsquo;est égal, le programme met la valeur constante de 0 dans <code>ECX</code></li>
<li>Si <code>ECX</code> vaut <code>7</code>, le programme quitte la boucle et affiche <code>Correct!</code> avec la fonction <code>putchar_unlocked</code>.</li>
<li>Si ce n&rsquo;est pas égale il quitte la bouble et affiche <code>Wrong!</code>.</li>
</ol>
<p>En voyant ca on peut se dire que le programme n&rsquo;a aucune logique car le compteur dans le registre <code>ECX</code> serait toujours remis à <code>0</code>, mais que nenni car il reste encore une partie du code de hook que l&rsquo;on avons pas encore analysé, si vous vous souvenez bien le hook du syscall de nombre <code>222</code> vérifie si la fonction <code>arp_main</code> a déjà été patchée et si c&rsquo;est le cas voici ce qu&rsquo;elle va faire:</p>
<p><img src="./assets/screenshot_hook_222_2.png" alt=""></p>
<p>Si la fonction <code>arp_main</code> est déjà patchée, autrement dit si l&rsquo;appel au syscall se fait depuis la fonction <code>arp_main</code> elle même, on remarque ce qui pourrait s&rsquo;apparenter à un <code>switch case</code> (là ce sont plus des <code>if/else</code> chainés mais bref&hellip;) en fonction de l&rsquo;<code>uint32_t</code> pointée à l&rsquo;adresse <code>0x80a4518</code>, dans <code>Binary Ninja</code> elle correspond à ceci:</p>
<p><img src="./assets/screenshot_arp_main_3.png" alt=""></p>
<p>En modifiant l&rsquo;<code>uint32_t</code> présent à <code>0x80a4518</code>, par exemple avec une valeur de <code>5</code>, l&rsquo;instruction présente dans la boucle deviendra:</p>
<p><img src="./assets/screenshot_arp_main_4.png" alt=""></p>
<p>La logique apparait maintenant de manière plus claire! A chaque tour de boucle, c&rsquo;est l&rsquo;appel au syscall et donc au hook qui va changer la valeur mise dans le registre <code>ECX</code> avant d&rsquo;être comparé à <code>7</code>!</p>
<p>Et en plus de modifier le conteur, la constante <code>0xe296df0b</code> servant à chiffrer les 4 octets lus dans le fichier &ldquo;secret&rdquo; ainsi que la constante <code>0x544aa692</code> utilisé pour la comparaison à chaque tour de boucle vont être <code>XOR</code>ées avec des valeurs différentes en fonction de l&rsquo;index de la boucle. Sans cela, le contenu requis du fichier &ldquo;secret&rdquo; serait 4 octets répétés!</p>
<p><em>En résumé:</em></p>
<p>Pour obtenir le flag il va falloir déterminer quel contenu du fichier <code>secret</code> renvoie la valeur <code>Correct!</code>. Pour déterminer, les 4 premiers caractères du flag:</p>
<ol>
<li>Le contenu de notre fichier <code>secret</code> est lu <code>4</code> par <code>4</code> octets, sous forme d&rsquo;un <code>uint32_t</code>.</li>
<li>cet entier subit alors cette opération:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">y</span> <span class="o">=</span> x * 0xe296df0b + 0x14800841
</span></span></code></pre></div><ol start="3">
<li>Lors de l&rsquo;appel au syscall, la valeur <code>y</code> est évaluée dans un polynôme:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">p<span class="o">(</span>y<span class="o">)</span> <span class="o">=</span> 0x45f90000 * y^2 + 0xfd20dcb3 * y + 0xa0f27f57
</span></span></code></pre></div><ol start="4">
<li>La valeur <code>p(y)</code> est comparée à <code>0x544aa692</code></li>
</ol>
<p>Il s&rsquo;agit d&rsquo;un simple polynôme du second degré donc rien de biens méchant mais autant le fait que les valeurs résultantes des multiplications avec <code>imul</code> seront splittés entre les registres <code>EAX</code> et <code>EBX</code> rend la chose un peu plus compliqué, utilisons <code>z3</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mh">0xe296df0b</span> <span class="o">+</span> <span class="mh">0x14800841</span>
</span></span><span class="line"><span class="cl"><span class="n">cons</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="mh">0x45f90000</span> <span class="o">+</span> <span class="mh">0xfd20dcb3</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="mh">0xa0f27f57</span> <span class="o">==</span> <span class="mh">0x544aa692</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">as_long</span><span class="p">()</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;little&#39;</span><span class="p">))</span>
</span></span></code></pre></div><p>Résultat:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="sa">b</span><span class="s1">&#39;HTB{&#39;</span>
</span></span></code></pre></div><p>Il ne reste plus qu&rsquo;à appliquer le même principe pour les octets restants du fichier en appliquant les <code>XOR</code>s respectifs pour chaque tour de boucle:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">init_values</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xe296df0b</span><span class="p">,</span> <span class="mh">0x544aa692</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">init_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">xor_values</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mh">0xb0796ab2</span><span class="p">,</span> <span class="mh">0x3b3211d</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mh">0xccddf7bc</span><span class="p">,</span> <span class="mh">0x7d2691d5</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mh">0x16d7ead8</span><span class="p">,</span> <span class="mh">0x98ad6bfb</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mh">0x7289e68</span><span class="p">,</span> <span class="mh">0x4a0a9a7a</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mh">0xf6804ff8</span><span class="p">,</span> <span class="mh">0x617e30ed</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="mh">0x6ea0855c</span><span class="p">,</span> <span class="mh">0xc28d160b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">flag</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">BitVec</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mh">0x14800841</span>
</span></span><span class="line"><span class="cl">    <span class="n">cons</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="mh">0x45f90000</span> <span class="o">+</span> <span class="mh">0xfd20dcb3</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="mh">0xa0f27f57</span> <span class="o">==</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span> <span class="o">+=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">as_long</span><span class="p">()</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;little&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">xor_values</span><span class="p">):</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">xor_values</span><span class="p">[</span><span class="n">index</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># HTB{_C0mpr0M1s3d_B00tcH41n_}</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Ce challenge aura été extrémement intéressant de par le fait qu&rsquo;il retrace la mise en place d&rsquo;un <code>OS TinyCore</code> entier, il part du bootloader pour arriver à une exécution de code pirate à l&rsquo;intérieur de la libc et du binaire <code>busybox</code> en passant par un hooking de syscall. Il m&rsquo;a permis de mieux comprendre comment un <code>bootkit</code> fonctionne et comment reverse un code s&rsquo;exécutant en <code>Real Mode</code> et surtout m&rsquo;aura fait progresser dans l&rsquo;utilisation de l&rsquo;API de <code>Binary Ninja</code> haha ;) !</p>
</div>
  
    <div class="mt-16">

</div>
  
</article>
      </div>
    </main><footer class="fixed left-0 bottom-0 w-full bg-base px-page-gutter">
  <div class="flex justify-center items-center h-footer-height">
    <div
      class="flex flex-row w-full max-w-content justify-between lowercase italic gap-3"
    >
      <nav>
        <ul class="flex text-md space-x-3 sm:space-x-6">
          
        </ul>
      </nav>
      <span class="text-muted hidden md:block">
        &copy;
        2024
        <a
          href="https://github.com/ntk148v/hugo-toigian"
          class="font-bold hover:underline"
          >hugo-toigian</a
        >
      </span>
      <div id="header-theme-button">
        <svg
          id="dark_mode_btn"
          class="hidden toolbox-btn"
          width="18px"
          height="18px"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z"
          />
        </svg>
        <svg
          id="light_mode_btn"
          class="hidden toolbox-btn"
          width="18px"
          height="18px"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z"
          />
        </svg>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
